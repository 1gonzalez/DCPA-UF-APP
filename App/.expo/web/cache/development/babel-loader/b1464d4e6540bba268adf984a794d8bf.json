{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport Linking from \"react-native-web/dist/exports/Linking\";\nimport { ActionSheetIOS } from \"react-native-web/dist/index\";\nimport Alert from \"react-native-web/dist/exports/Alert\";\nimport { appKeys, isIOS } from \"./constants\";\nexport var getAvailableApps = function getAvailableApps(prefixes) {\n  var availableApps, app, avail;\n  return _regeneratorRuntime.async(function getAvailableApps$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          availableApps = [];\n          _context.t0 = _regeneratorRuntime.keys(prefixes);\n\n        case 2:\n          if ((_context.t1 = _context.t0()).done) {\n            _context.next = 11;\n            break;\n          }\n\n          app = _context.t1.value;\n\n          if (!prefixes.hasOwnProperty(app)) {\n            _context.next = 9;\n            break;\n          }\n\n          _context.next = 7;\n          return _regeneratorRuntime.awrap(isAppInstalled(app, prefixes));\n\n        case 7:\n          avail = _context.sent;\n\n          if (avail) {\n            availableApps.push(app);\n          }\n\n        case 9:\n          _context.next = 2;\n          break;\n\n        case 11:\n          return _context.abrupt(\"return\", availableApps);\n\n        case 12:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, null, null, null, Promise);\n};\nexport function isAppInstalled(app, prefixes) {\n  return new Promise(function (resolve) {\n    if (!(app in prefixes)) {\n      return resolve(false);\n    }\n\n    Linking.canOpenURL(prefixes[app]).then(function (result) {\n      resolve(!!result);\n    }).catch(function () {\n      return resolve(false);\n    });\n  });\n}\n\nfunction isSupportedApp(app) {\n  return appKeys.includes(app);\n}\n\nfunction getNotSupportedApps(apps) {\n  return apps.filter(function (app) {\n    return !isSupportedApp(app);\n  });\n}\n\nexport function checkNotSupportedApps(apps) {\n  var notSupportedApps = getNotSupportedApps(apps);\n\n  if (notSupportedApps.length) {\n    throw new MapsException(\"appsWhiteList [\" + notSupportedApps + \"] are not supported apps, please provide some of the supported apps [\" + appKeys + \"]\");\n  }\n}\nexport function askAppChoice(_ref) {\n  var dialogTitle = _ref.dialogTitle,\n      dialogMessage = _ref.dialogMessage,\n      cancelText = _ref.cancelText,\n      appsWhiteList = _ref.appsWhiteList,\n      prefixes = _ref.prefixes,\n      appTitles = _ref.appTitles;\n  return new Promise(function _callee(resolve) {\n    var availableApps, _options, options;\n\n    return _regeneratorRuntime.async(function _callee$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return _regeneratorRuntime.awrap(getAvailableApps(prefixes));\n\n          case 2:\n            availableApps = _context2.sent;\n\n            if (appsWhiteList && appsWhiteList.length) {\n              availableApps = availableApps.filter(function (appName) {\n                return appsWhiteList.includes(appName);\n              });\n            }\n\n            if (!(availableApps.length < 2)) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\", resolve(availableApps[0] || null));\n\n          case 6:\n            if (!isIOS) {\n              _context2.next = 11;\n              break;\n            }\n\n            _options = availableApps.map(function (app) {\n              return appTitles[app];\n            });\n\n            _options.push(cancelText);\n\n            ActionSheetIOS.showActionSheetWithOptions({\n              title: dialogTitle,\n              message: dialogMessage,\n              options: _options,\n              cancelButtonIndex: _options.length - 1\n            }, function (buttonIndex) {\n              if (buttonIndex === _options.length - 1) {\n                return resolve(null);\n              }\n\n              return resolve(availableApps[buttonIndex]);\n            });\n            return _context2.abrupt(\"return\");\n\n          case 11:\n            options = availableApps.map(function (app) {\n              return {\n                text: appTitles[app],\n                onPress: function onPress() {\n                  return resolve(app);\n                }\n              };\n            });\n            options.unshift({\n              text: cancelText,\n              onPress: function onPress() {\n                return resolve(null);\n              },\n              style: 'cancel'\n            });\n            return _context2.abrupt(\"return\", Alert.alert(dialogTitle, dialogMessage, options, {\n              cancelable: true,\n              onDismiss: function onDismiss() {\n                return resolve(null);\n              }\n            }));\n\n          case 14:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  });\n}\nexport function checkOptions(options, prefixes) {\n  if (!options || typeof options !== 'object') {\n    throw new MapsException('First parameter of `showLocation` should contain object with options.');\n  }\n\n  if (!('latitude' in options) || !('longitude' in options)) {\n    throw new MapsException('First parameter of `showLocation` should contain object with at least keys `latitude` and `longitude`.');\n  }\n\n  if ('title' in options && options.title && typeof options.title !== 'string') {\n    throw new MapsException('Option `title` should be of type `string`.');\n  }\n\n  if ('googleForceLatLon' in options && options.googleForceLatLon && typeof options.googleForceLatLon !== 'boolean') {\n    throw new MapsException('Option `googleForceLatLon` should be of type `boolean`.');\n  }\n\n  if ('googlePlaceId' in options && options.googlePlaceId && typeof options.googlePlaceId !== 'string') {\n    throw new MapsException('Option `googlePlaceId` should be of type `string`.');\n  }\n\n  if ('app' in options && options.app && !(options.app in prefixes)) {\n    throw new MapsException('Option `app` should be undefined, null, or one of the following: \"' + Object.keys(prefixes).join('\", \"') + '\".');\n  }\n\n  if ('appsWhiteList' in options && options.appsWhiteList) {\n    checkNotSupportedApps(options.appsWhiteList);\n  }\n\n  if ('appTitles' in options && options.appTitles && typeof options.appTitles !== 'object') {\n    throw new MapsException('Option `appTitles` should be of type `object`.');\n  }\n}\n\nvar MapsException = function MapsException(message) {\n  _classCallCheck(this, MapsException);\n\n  this.message = message;\n  this.name = 'MapsException';\n};","map":{"version":3,"sources":["/mnt/d/Users/Caputo/Desktop/IDEs/VSCode/CEN3031/Project/DCPA-UF-APP/App/node_modules/react-native-map-link/src/utils.js"],"names":["ActionSheetIOS","appKeys","isIOS","getAvailableApps","prefixes","availableApps","app","hasOwnProperty","isAppInstalled","avail","push","Promise","resolve","Linking","canOpenURL","then","result","catch","isSupportedApp","includes","getNotSupportedApps","apps","filter","checkNotSupportedApps","notSupportedApps","length","MapsException","askAppChoice","dialogTitle","dialogMessage","cancelText","appsWhiteList","appTitles","appName","options","map","showActionSheetWithOptions","title","message","cancelButtonIndex","buttonIndex","text","onPress","unshift","style","Alert","alert","cancelable","onDismiss","checkOptions","googleForceLatLon","googlePlaceId","Object","keys","join","name"],"mappings":"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","sourcesContent":["/**\n * React Native Map Link\n */\n\nimport {Linking, ActionSheetIOS, Alert} from 'react-native';\n\nimport {appKeys, isIOS} from './constants';\n\n/**\n * Get available navigation apps.\n */\nexport const getAvailableApps = async (prefixes) => {\n  const availableApps = [];\n  for (const app in prefixes) {\n    if (prefixes.hasOwnProperty(app)) {\n      const avail = await isAppInstalled(app, prefixes);\n      if (avail) {\n        availableApps.push(app);\n      }\n    }\n  }\n\n  return availableApps;\n};\n\n/**\n * Check if a given map app is installed.\n *\n * @param {string} app\n * @param {object} prefixes\n * @returns {Promise<boolean>}\n */\nexport function isAppInstalled(app, prefixes) {\n  return new Promise((resolve) => {\n    if (!(app in prefixes)) {\n      return resolve(false);\n    }\n\n    Linking.canOpenURL(prefixes[app])\n      .then((result) => {\n        resolve(!!result);\n      })\n      .catch(() => resolve(false));\n  });\n}\n\n/**\n * Check if a given app is supported by this library\n *\n * @param {string} app\n * @returns {boolean}\n */\nfunction isSupportedApp(app) {\n  return appKeys.includes(app);\n}\n\n/**\n * Get a list of not supported apps from a given array of apps\n *\n * @param {array} apps\n * @returns {array}\n */\nfunction getNotSupportedApps(apps) {\n  return apps.filter((app) => !isSupportedApp(app));\n}\n\n/**\n * Throws an exception if some of the given apps is not supported\n *\n * @param {array} apps\n */\nexport function checkNotSupportedApps(apps) {\n  const notSupportedApps = getNotSupportedApps(apps);\n  if (notSupportedApps.length) {\n    throw new MapsException(\n      `appsWhiteList [${notSupportedApps}] are not supported apps, please provide some of the supported apps [${appKeys}]`,\n    );\n  }\n}\n\n/**\n * Ask the user to choose one of the available map apps.\n * @param {{\n *     title: string | undefined | null\n *     message: string | undefined | null\n *     cancelText: string | undefined | null\n *     appsWhiteList: string[] | null\n *     prefixes: string[],\n *     appTitles: object | undefined | null\n * }} options\n * @returns {Promise}\n */\nexport function askAppChoice({\n  dialogTitle,\n  dialogMessage,\n  cancelText,\n  appsWhiteList,\n  prefixes,\n  appTitles,\n}) {\n  return new Promise(async (resolve) => {\n    let availableApps = await getAvailableApps(prefixes);\n\n    if (appsWhiteList && appsWhiteList.length) {\n      availableApps = availableApps.filter((appName) =>\n        appsWhiteList.includes(appName),\n      );\n    }\n\n    if (availableApps.length < 2) {\n      return resolve(availableApps[0] || null);\n    }\n\n    if (isIOS) {\n      const options = availableApps.map((app) => appTitles[app]);\n      options.push(cancelText);\n\n      ActionSheetIOS.showActionSheetWithOptions(\n        {\n          title: dialogTitle,\n          message: dialogMessage,\n          options: options,\n          cancelButtonIndex: options.length - 1,\n        },\n        (buttonIndex) => {\n          if (buttonIndex === options.length - 1) {\n            return resolve(null);\n          }\n          return resolve(availableApps[buttonIndex]);\n        },\n      );\n\n      return;\n    }\n\n    const options = availableApps.map((app) => ({\n      text: appTitles[app],\n      onPress: () => resolve(app),\n    }));\n    options.unshift({\n      text: cancelText,\n      onPress: () => resolve(null),\n      style: 'cancel',\n    });\n\n    return Alert.alert(dialogTitle, dialogMessage, options, {\n      cancelable: true,\n      onDismiss: () => resolve(null),\n    });\n  });\n}\n\n/**\n * Check if options are valid and well passed\n *\n * @param {{\n *     latitude: number | string,\n *     longitude: number | string,\n *     sourceLatitude: number | undefined | null,\n *     sourceLongitude: number | undefined | null,\n *     googleForceLatLon: boolean | undefined | null,\n *     googlePlaceId: number | undefined | null,\n *     title: string | undefined | null,\n *     app: string | undefined | null\n *     dialogTitle: string | undefined | null\n *     dialogMessage: string | undefined | null\n *     cancelText: string | undefined | null\n *     naverCallerName: string | undefined\n * }} options\n * @param {object} prefixes\n */\nexport function checkOptions(options, prefixes) {\n  if (!options || typeof options !== 'object') {\n    throw new MapsException(\n      'First parameter of `showLocation` should contain object with options.',\n    );\n  }\n  if (!('latitude' in options) || !('longitude' in options)) {\n    throw new MapsException(\n      'First parameter of `showLocation` should contain object with at least keys `latitude` and `longitude`.',\n    );\n  }\n  if (\n    'title' in options &&\n    options.title &&\n    typeof options.title !== 'string'\n  ) {\n    throw new MapsException('Option `title` should be of type `string`.');\n  }\n  if (\n    'googleForceLatLon' in options &&\n    options.googleForceLatLon &&\n    typeof options.googleForceLatLon !== 'boolean'\n  ) {\n    throw new MapsException(\n      'Option `googleForceLatLon` should be of type `boolean`.',\n    );\n  }\n  if (\n    'googlePlaceId' in options &&\n    options.googlePlaceId &&\n    typeof options.googlePlaceId !== 'string'\n  ) {\n    throw new MapsException(\n      'Option `googlePlaceId` should be of type `string`.',\n    );\n  }\n  if ('app' in options && options.app && !(options.app in prefixes)) {\n    throw new MapsException(\n      'Option `app` should be undefined, null, or one of the following: \"' +\n        Object.keys(prefixes).join('\", \"') +\n        '\".',\n    );\n  }\n  if ('appsWhiteList' in options && options.appsWhiteList) {\n    checkNotSupportedApps(options.appsWhiteList);\n  }\n  if (\n    'appTitles' in options &&\n    options.appTitles &&\n    typeof options.appTitles !== 'object'\n  ) {\n    throw new MapsException('Option `appTitles` should be of type `object`.');\n  }\n}\n\nclass MapsException {\n  constructor(message) {\n    this.message = message;\n    this.name = 'MapsException';\n  }\n}\n"]},"metadata":{},"sourceType":"module"}